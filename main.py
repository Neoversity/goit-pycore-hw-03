# Завдання 1____________________________________________________________________________________________
# Створіть функцію get_days_from_today(date), яка розраховує кількість днів між заданою датою і поточною датою.
#
# Вимоги до завдання:
# Функція приймає один параметр: date — рядок, що представляє дату у форматі 'РРРР-ММ-ДД' (наприклад, '2020-10-09').
# Функція повертає ціле число, яке вказує на кількість днів від заданої дати до поточної.
# Якщо задана дата пізніша за поточну, результат має бути від'ємним.
# У розрахунках необхідно враховувати лише дні, ігноруючи час (години, хвилини, секунди).
# Для роботи з датами слід використовувати модуль datetime Python.
# from datetime import datetime
from datetime import datetime


def get_days_from_today(date):
    """
    Розраховує кількість днів між заданою датою та поточною датою.

    Параметри:
    date (str): Рядок, що представляє дату у форматі 'РРРР-ММ-ДД' (наприклад, '2020-10-09').

    Повертає:
    int: Кількість днів від заданої дати до поточної. Якщо задана дата пізніша за поточну, результат має бути від'ємним.
    """
    # Перетворюємо рядок дати у об'єкт datetime
    date_object = datetime.strptime(date, '%Y-%m-%d')
    # Отримуємо поточну дату
    current_date = datetime.today()
    # Розраховуємо різницю між двома датами
    delta = date_object - current_date

    # Повертаємо кількість днів у вигляді цілого числа
    return delta.days


# Приклад використання:
# date = '2024-10-10'
# print(get_days_from_today(date))


# Завдання 2__________________________________________________________________________________________________
# Щоб виграти головний приз лотереї, необхідний збіг кількох номерів на лотерейному квитку з числами, що випали
# випадковим чином і в певному діапазоні під час чергового тиражу. Наприклад, необхідно вгадати шість чисел
# від 1 до 49 чи п'ять чисел від 1 до 36 тощо.
# Вам необхідно написати функцію get_numbers_ticket(min, max, quantity), яка допоможе генерувати набір унікальних
# випадкових чисел для таких лотерей. Вона буде повертати випадковий набір чисел у межах заданих параметрів,
# причому всі випадкові числа в наборі повинні бути унікальні.
#
# Вимоги до завдання:
# Параметри функції:
# min - мінімальне можливе число у наборі (не менше 1).
# max - максимальне можливе число у наборі (не більше 1000).
# quantity - кількість чисел, які потрібно вибрати (значення між min і max).
# Функція генерує вказану кількість унікальних чисел у заданому діапазоні.
# Функція повертає список випадково вибраних, відсортованих чисел. Числа в наборі не повинні повторюватися.
# Якщо параметри не відповідають заданим обмеженням, функція повертає пустий список.


import random


def get_numbers_ticket(min, max, quantity):
    """
    Генерує унікальний набір випадкових чисел у заданому діапазоні.

    Параметри:
    min_val (int): Мінімальне можливе число у наборі (не менше 1).
    max_val (int): Максимальне можливе число у наборі (не більше 1000).
    quantity (int): Кількість чисел, які потрібно вибрати.

    Повертає:
    list: Список унікальних, відсортованих чисел.
    """
    # Перевірка вхідних параметрів
    if not (1 <= min <= max <= 1000):
        return []

    # Перевірка кількості чисел
    if quantity > (max - min + 1):
        return []

    # Генеруємо унікальні випадкові числа
    numbers = random.sample(range(min, max + 1), quantity)

    # Сортуємо та повертаємо результат
    return sorted(numbers)


# print(get_numbers_ticket(1, 49, 6))


# Завдання 3______________________________________________________________________________________________
#
# У вашій компанії ведеться активна маркетингова кампанія за допомогою SMS-розсилок.
# Для цього ви збираєте телефонні номери клієнтів із бази даних, але часто стикаєтеся з тим,
# що номери записані у різних форматах. Наприклад:
#
# "    +38(050)123-32-34"
# "     0503451234"
# "(050)8889900"
# "38050-111-22-22"
# "38050 111 22 11   "
#
# Ваш сервіс розсилок може ефективно відправляти повідомлення лише тоді,
# коли номери телефонів представлені у коректному форматі. Тому вам необхідна функція,
# яка автоматично нормалізує номери телефонів до потрібного формату,
# видаляючи всі зайві символи та додаючи міжнародний код країни, якщо потрібно.
#
# Розробіть функцію normalize_phone(phone_number), що нормалізує телефонні номери до стандартного формату,
# залишаючи тільки цифри та символ '+' на початку.
# Функція приймає один аргумент - рядок з телефонним номером у будь-якому форматі та перетворює його на стандартний формат,
# залишаючи тільки цифри та символ '+'. Якщо номер не містить міжнародного коду,
# функція автоматично додає код '+38' (для України). Це гарантує, що всі номери будуть придатними для відправлення SMS.
#
# Вимоги до завдання:
#
# Параметр функції phone_number - це рядок з телефонним номером у різноманітних форматах.
# Функція видаляє всі символи, крім цифр та символу '+'.
# Якщо міжнародний код відсутній, функція додає код '+38'.
# Це враховує випадки, коли номер починається з '380' (додається лише '+')
# та коли номер починається без коду (додається '+38').
# Функція повертає нормалізований телефонний номер у вигляді рядка.
#
#
# Рекомендації для виконання:
#
# Використовуйте модуль re для регулярних виразів для видалення непотрібних символів.
# Перевірте, чи номер починається з '+', і виправте префікс згідно з вказівками.
# Видаліть всі символи, крім цифр та '+', з номера телефону.
# На забувайте повертати нормалізований номер телефону з функції.


import re


def normalize_phone(phone_number):
    """
    Нормалізує телефонний номер до стандартного формату.

    Параметри:
    phone_number (str): Рядок з телефонним номером у різноманітних форматах.

    Повертає:
    list: Список нормалізованих телефонних номерів у вигляді рядків.
    """

    normalized_numbers = []
    for phone_number in phone_number:
        # Використовуємо регулярний вираз для видалення всіх символів, окрім цифр та символу '+'
        normalized_number = re.sub(r'\D+', '', phone_number)

        # Додаємо міжнародний код країни, якщо він відсутній
        if normalized_number[0] != '+':
            if normalized_number.startswith('380'):
                normalized_number = '+' + normalized_number
            else:
                normalized_number = '+38' + normalized_number

        normalized_numbers.append(normalized_number)

    return normalized_numbers


# Приклад використання:
# phone_number = [
#     "067\\t123 4567",
#     "(095) 234-5678\\n",
#     "+380 44 123 4567",
#     "380501234567",
#     "    +38(050)123-32-34",
#     "     0503451234",
#     "(050)88+89+900",
#     "38050-111-22-22",
#     "38050 111 22 11   ",
# ]
# print(normalize_phone(phone_number))

# Завдання 4__________________________________________________________________________________________________
#
# У межах вашої організації, ви відповідаєте за організацію привітань колег з днем народження.
# Щоб оптимізувати цей процес, вам потрібно створити функцію get_upcoming_birthdays, яка допоможе вам визначати,
# кого з колег потрібно привітати.
# Функція повинна повернути список всіх у кого день народження вперед на 7 днів включаючи поточний день.
#
# У вашому розпорядженні є список users, кожен елемент якого містить інформацію про ім'я користувача та його день народження.
# Оскільки дні народження колег можуть припадати на вихідні,
# ваша функція також повинна враховувати це та переносити дату привітання на наступний робочий день, якщо необхідно.
#
# Вимоги до завдання:
#
# Параметр функції users - це список словників, де кожен словник містить ключі name (ім'я користувача, рядок)
# та birthday (день народження, рядок у форматі 'рік.місяць.дата').
# Функція має визначати, чиї дні народження випадають вперед на 7 днів включаючи поточний день.
# Якщо день народження припадає на вихідний, дата привітання переноситься на наступний понеділок.
# Функція повертає список словників, де кожен словник містить інформацію про користувача (ключ name)
# та дату привітання (ключ congratulation_date, дані якого у форматі рядка 'рік.місяць.дата').
#
#
# Рекомендації для виконання:
#
# Припускаємо, що ви отримали список users, де кожен словник містить name (ім'я користувача)
# та birthday (дата народження у форматі рядка 'рік.місяць.дата').
# Ви повинні перетворити дати народження з рядків у об'єкти datetime.
# Конвертуйте дату народження із рядка у datetime об'єкт - datetime.strptime(user["birthday"], "%Y.%m.%d").date().
# Оскільки потрібна лише дата (без часу), використовуйте .date() для отримання тільки дати.
# Визначте поточну дату системи за допомогою datetime.today().date().
# Пройдіться по списку users та аналізуйте дати народження кожного користувача (for user in users:).
# Перевірте, чи вже минув день народження в цьому році (if birthday_this_year < today). Якщо так, розгляньте дату на наступний рік.
# Визначте різницю між днем народження та поточним днем для визначення днів народження на наступний тиждень.
# Перевірте, чи день народження припадає на вихідний. Якщо так, перенесіть дату привітання на наступний понеділок.
# Створіть структуру даних, яка зберігатиме ім'я користувача та відповідну дату привітання,
# якщо день народження відбувається протягом наступного тижня.
# Виведіть зібрані дані у вигляді списку словників з іменами користувачів та датами привітань.

from datetime import datetime, timedelta

def get_congratulation_date(user):
    return datetime.strptime(user["congratulation_date"], "%Y.%m.%d")

def get_upcoming_birthdays(users):
    """
    Визначає користувачів, дні народження яких випадають вперед на 7 днів включаючи поточний день.

    Параметри:
    users (list): Список словників, де кожен словник містить інформацію про користувача.

    Повертає:
    list: Список словників з ім'ям користувача та датою привітання, відсортований за збільшуючою датою.
    """
    today = datetime.today().date()
    upcoming_birthdays = []

    for user in users:
        birthday = datetime.strptime(user["birthday"], "%Y.%m.%d").date()
        birthday_this_year = birthday.replace(year=today.year)

        # Якщо день народження вже випав у цьому році, розглядаємо на наступний рік
        if birthday_this_year < today:
            birthday_this_year = birthday_this_year.replace(year=today.year + 1)

        # Визначаємо різницю між днем народження та поточним днем
        days_until_birthday = (birthday_this_year - today).days

        # Перевіряємо, чи день народження припадає на вихідний, переносячи його на наступний понеділок
        if days_until_birthday <= 7:
            if birthday_this_year.weekday() >= 5:  # Якщо вихідний
                birthday_this_year += timedelta(days=(7 - birthday_this_year.weekday()))

            upcoming_birthdays.append(
                {"name": user["name"], "congratulation_date": birthday_this_year.strftime("%Y.%m.%d")})

        # Сортування за збільшуючою датою привітання
        upcoming_birthdays = sorted(upcoming_birthdays, key=get_congratulation_date)

    return upcoming_birthdays


# Приклад використання:
# users = [
#     {"name": "John", "birthday": "2024.04.16"},
#     {"name": "Alice", "birthday": "1984.04.14"},
#     {"name": "Bob", "birthday": "2024.04.18"},
#     {"name": "Jane", "birthday": "2024.04.19"},
# ]
#
# upcoming_birthdays = get_upcoming_birthdays(users)
# print(upcoming_birthdays)
